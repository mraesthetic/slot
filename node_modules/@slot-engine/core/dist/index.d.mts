declare const SPIN_TYPE: {
    readonly BASE_GAME: "basegame";
    readonly FREE_SPINS: "freespins";
};

interface GameConfigOptions<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> {
    /**
     * The unique identifier of the game, used for configuration and identification.
     */
    id: string;
    /**
     * The name of the game, used for display purposes.
     */
    name: string;
    /**
     * A GameMode is the core structure of a slot, defining the board,\
     * bet cost, win type, and other properties.
     */
    gameModes: TGameModes;
    /**
     * A list of all symbols that will appear on the reels.
     */
    symbols: TSymbols;
    /**
     * A mapping from spin type to scatter counts to the number of free spins awarded.
     *
     * @example
     * ```ts
     * scatterToFreespins: {
     *   [SPIN_TYPE.BASE_GAME]: {
     *     3: 10,
     *     4: 12,
     *     5: 15,
     *   },
     *   [SPIN_TYPE.FREE_SPINS]: {
     *     3: 6,
     *     4: 8,
     *     5: 10,
     *   },
     * },
     * ```
     */
    scatterToFreespins: Record<string, Record<number, number>>;
    /**
     * If set, this will pad the board with symbols on the top and bottom of the reels.\
     * Useful for teasing symbols right above or below the active board.
     *
     * Default: 1
     */
    padSymbols?: number;
    /**
     * The maximum win multiplier of the game, e.g. 5000 for a 5000x max win.
     */
    maxWinX: number;
    /**
     * Custom additional state that can be used in game flow logic.
     */
    userState?: TUserState;
    /**
     * Hooks are used to inject custom logic at specific points in the game flow.\
     * Some required hooks must be implemented for certain features to work.
     */
    hooks: GameHooks<TGameModes, TSymbols, TUserState>;
    /**
     * If, for some reason, you run your game WITHOUT `cd`ing into the game root,\
     * you can specify the root directory here to ensure assets are resolved correctly.\
     * Normally, this is not needed.
     */
    rootDir?: string;
}
type GameConfig<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> = Required<Omit<GameConfigOptions<TGameModes, TSymbols, TUserState>, "symbols">> & {
    /**
     * A map of all symbols.
     */
    symbols: Map<keyof TSymbols & string, TSymbols[keyof TSymbols]>;
    outputDir: string;
    rootDir: string;
    /**
     * A mapping of spin types to the number of scatter symbols required to trigger anticipation.
     */
    anticipationTriggers: Record<(typeof SPIN_TYPE)[keyof typeof SPIN_TYPE], number>;
};

declare class Simulation {
    readonly gameConfigOpts: GameConfigOptions;
    readonly gameConfig: GameConfig;
    readonly simRunsAmount: Partial<Record<string, number>>;
    readonly concurrency: number;
    private debug;
    private actualSims;
    private library;
    private recorder;
    private wallet;
    constructor(opts: SimulationOptions, gameConfigOpts: GameConfigOptions);
    runSimulation(opts: SimulationConfigOptions): Promise<void>;
    /**
     * Runs all simulations for a specific game mode.
     */
    spawnWorkersForGameMode(opts: {
        mode: string;
        simNumsToCriteria: Record<number, string>;
    }): Promise<void>;
    callWorker(opts: {
        basePath: string;
        mode: string;
        simStart: number;
        simEnd: number;
        index: number;
        totalSims: number;
    }): Promise<unknown>;
    /**
     * Will run a single simulation until the specified criteria is met.
     */
    runSingleSimulation(opts: {
        simId: number;
        mode: string;
        criteria: string;
        index: number;
    }): void;
    /**
     * If a simulation does not meet the required criteria, reset the state to run it again.
     *
     * This also runs once before each simulation to ensure a clean state.
     */
    protected resetSimulation(ctx: GameContext): void;
    protected resetState(ctx: GameContext): void;
    /**
     * Contains and executes the entire game logic:
     * - Drawing the board
     * - Evaluating wins
     * - Updating wallet
     * - Handling free spins
     * - Recording events
     *
     * You can customize the game flow by implementing the `onHandleGameFlow` hook in the game configuration.
     */
    protected handleGameFlow(ctx: GameContext): void;
    /**
     * Creates a CSV file in the format "simulationId,weight,payout".
     *
     * `weight` defaults to 1.
     */
    private writeLookupTableCSV;
    /**
     * Creates a CSV file in the format "simulationId,criteria,payoutBase,payoutFreespins".
     */
    private writeLookupTableSegmentedCSV;
    private writeRecords;
    private writeIndexJson;
    private writeBooksJson;
    private logSymbolOccurrences;
    /**
     * Compiles user configured game to JS for use in different Node processes
     */
    private preprocessFiles;
    private getSimRangesForChunks;
    private mergeRecords;
    /**
     * Generates reelset CSV files for all game modes.
     */
    private generateReelsetFiles;
    /**
     * Confirms all pending records and adds them to the main records list.
     */
    confirmRecords(ctx: GameContext): void;
}
type SimulationOptions = {
    /**
     * Object containing the game modes and their respective simulation runs amount.
     */
    simRunsAmount: Partial<Record<string, number>>;
    /**
     * Number of concurrent processes to use for simulations.
     *
     * Default: 6
     */
    concurrency?: number;
};
type SimulationConfigOptions = {
    debug?: boolean;
};

declare class ResultSet<TUserState extends AnyUserData> {
    criteria: string;
    quota: number;
    multiplier?: number;
    reelWeights: ReelWeights<TUserState>;
    userData?: Record<string, any>;
    forceMaxWin?: boolean;
    forceFreespins?: boolean;
    evaluate?: (ctx: GameContext<AnyGameModes, AnySymbols, TUserState>) => boolean;
    constructor(opts: ResultSetOpts<TUserState>);
    static assignCriteriaToSimulations(ctx: Simulation, gameModeName: string): Record<number, string>;
    /**
     * Checks if core criteria is met, e.g. target multiplier or max win.
     */
    meetsCriteria(ctx: GameContext): boolean;
}
interface ResultSetOpts<TUserState extends AnyUserData> {
    /**
     * A short string to describe the criteria for this ResultSet.
     */
    criteria: string;
    /**
     * The quota of spins, out of the total simulations, that must be forced to meet the specified criteria.\
     * **Float from 0 to 1. Total quota of all ResultSets in a GameMode must be 1.**
     */
    quota: number;
    /**
     * The required multiplier for a simulated spin to be accepted.
     */
    multiplier?: number;
    /**
     * Configure the weights of the reels in this ResultSet.
     *
     * If you need to support dynamic / special reel weights based on the simulation context,\
     * you can provide an `evaluate` function that returns the desired weights.
     *
     * If the `evaluate` function returns a falsy value, the usual spin type based weights will be used.
     *
     * @example
     * ```ts
     * new ResultSet({
     *   criteria: "superFreespins",
     *   quota: 0.05,
     *   forceFreespins: true,
     *   reelWeights: {
     *     [SPIN_TYPE.BASE_GAME]: { base1: 1 },
     *     [SPIN_TYPE.FREE_SPINS]: { bonus1: 1, bonus2: 2 },
     *     evaluate: (ctx) => {
     *       if (ctx.state.userData.triggeredSuperFreespins) {
     *         return { superbonus: 1 }
     *       }
     *     }
     *   },
     *   userData: { forceSuperFreespins: true },
     * }),
     * ```
     */
    reelWeights: ReelWeights<TUserState>;
    /**
     * Optional data to use when evaluating the criteria.\
     * This can be used to pass additional context or parameters needed for the evaluation.
     */
    userData?: Record<string, any>;
    /**
     * If set, this will force the game to always trigger a max win.
     */
    forceMaxWin?: boolean;
    /**
     * If set, this will force the game to always trigger free spins.
     */
    forceFreespins?: boolean;
    /**
     * Custom function to evaluate if the criteria is met.
     *
     * E.g. use this to check for free spins that upgraded to super free spins\
     * or other arbitrary simulation criteria.
     */
    evaluate?: (ctx: GameContext<AnyGameModes, AnySymbols, TUserState>) => boolean;
}
interface ReelWeights<TUserState extends AnyUserData> {
    [SPIN_TYPE.BASE_GAME]: Record<string, number>;
    [SPIN_TYPE.FREE_SPINS]: Record<string, number>;
    evaluate?: (ctx: GameContext<AnyGameModes, AnySymbols, TUserState>) => Record<string, number> | undefined | null | false;
}

interface GameStateOptions<TUserState extends AnyUserData> {
    currentSimulationId: number;
    /**
     * e.g. "base", "freespins", etc. (depending on the game config)
     */
    currentGameMode: string;
    /**
     * Spin type constant as defined in `SPIN_TYPE`
     */
    currentSpinType: SpinType;
    /**
     * The current ResultSet for the active simulation run.
     */
    currentResultSet: ResultSet<any>;
    /**
     * Whether the criteria in the ResultSet for the current simulation has been met.
     */
    isCriteriaMet: boolean;
    /**
     * Number of freespins remaining in the current freespin round.
     */
    currentFreespinAmount: number;
    /**
     * Total amount of freespins awarded during the active simulation.
     */
    totalFreespinAmount: number;
    /**
     * Custom user data that can be used in game flow logic.
     */
    userData: TUserState;
    /**
     * Whether a max win has been triggered during the active simulation.
     */
    triggeredMaxWin: boolean;
    /**
     * Whether freespins have been triggered during the active simulation.
     */
    triggeredFreespins: boolean;
}
declare function createGameState<TUserState extends AnyUserData = AnyUserData>(opts?: Partial<GameStateOptions<TUserState>>): {
    currentSimulationId: number;
    currentGameMode: string;
    currentSpinType: SpinType;
    currentResultSet: ResultSet<any>;
    isCriteriaMet: boolean;
    currentFreespinAmount: number;
    totalFreespinAmount: number;
    userData: TUserState;
    triggeredMaxWin: boolean;
    triggeredFreespins: boolean;
};
type GameState<TUserState extends AnyUserData = AnyUserData> = ReturnType<typeof createGameState<TUserState>>;

declare class AbstractService {
    /**
     * Function that returns the current game context.
     */
    protected ctx: () => GameContext;
    constructor(ctx: () => GameContext);
}

declare class GameSymbol {
    readonly id: string;
    readonly pays?: Record<number, number>;
    readonly properties: Map<string, any>;
    constructor(opts: GameSymbolOpts);
    /**
     * Compares this symbol to another symbol or a set of properties.
     */
    compare(symbolOrProperties?: GameSymbol | Record<string, any>): boolean;
    /**
     * Creates a clone of this GameSymbol.
     */
    clone(): GameSymbol;
}
interface GameSymbolOpts {
    /**
     * Unique identifier for the symbol, e.g. "W", "H1", "L5", etc.
     */
    id: string;
    /**
     * Paytable for the symbol, where the key is the number of symbols and the value is the payout multiplier.
     */
    pays?: Record<number, number>;
    /**
     * Additional properties for the symbol, e.g. `multiplier` or `isWild`.
     *
     * Properties can help identify special symbols.
     *
     * @example
     * If your game has a "normal" scatter and a "super" scatter, you can define them like this:
     *
     * ```ts
     * properties: {
     *   isScatter: true,
     * }
     * ```
     */
    properties?: Record<string, any>;
}

declare class BoardService<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> extends AbstractService {
    private board;
    constructor(ctx: () => GameContext<TGameModes, TSymbols, TUserState>);
    /**
     * Resets the board to an empty state.\
     * This is called before drawing a new board.
     */
    resetBoard(): void;
    /**
     * Gets the current reels and symbols on the board.
     */
    getBoardReels(): Reels;
    getPaddingTop(): Reels;
    getPaddingBottom(): Reels;
    getAnticipation(): boolean[];
    /**
     * Gets the symbol at the specified reel and row index.
     */
    getSymbol(reelIndex: number, rowIndex: number): GameSymbol | undefined;
    /**
     * Sets the symbol at the specified reel and row index.
     */
    setSymbol(reelIndex: number, rowIndex: number, symbol: GameSymbol): void;
    private resetReels;
    /**
     * Sets the anticipation value for a specific reel.
     */
    setAnticipationForReel(reelIndex: number, value: boolean): void;
    /**
     * Counts how many symbols matching the criteria are on a specific reel.
     */
    countSymbolsOnReel(symbolOrProperties: GameSymbol | Record<string, any>, reelIndex: number): number;
    /**
     * Counts how many symbols matching the criteria are on the board.
     *
     * Passing a GameSymbol will compare by ID, passing a properties object will compare by properties.
     *
     * Returns a tuple where the first element is the total count, and the second element is a record of counts per reel index.
     */
    countSymbolsOnBoard(symbolOrProperties: GameSymbol | Record<string, any>): [number, Record<number, number>];
    /**
     * Checks if a symbol appears more than once on any reel in the current reel set.
     *
     * Useful to check for "forbidden" generations, e.g. 2 scatters on one reel.
     */
    isSymbolOnAnyReelMultipleTimes(symbol: GameSymbol): boolean;
    /**
     * Gets all reel stops (positions) where the specified symbol appears in the current reel set.\
     * Returns an array of arrays, where each inner array contains the positions for the corresponding reel.
     */
    getReelStopsForSymbol(reels: Reels, symbol: GameSymbol): number[][];
    /**
     * Combines multiple arrays of reel stops into a single array of reel stops.\
     */
    combineReelStops(...reelStops: number[][][]): number[][];
    /**
     * From a list of reel stops on reels, selects a random stop for a speficied number of random symbols.
     *
     * Mostly useful for placing scatter symbols on the board.
     */
    getRandomReelStops(reels: Reels, reelStops: number[][], amount: number): Record<number, number>;
    /**
     * Selects a random reel set based on the configured weights of the current result set.\
     * Returns the reels as arrays of GameSymbols.
     */
    getRandomReelset(): Reels;
    /**
     * Draws a board using specified reel stops.
     */
    drawBoardWithForcedStops(opts: {
        reels: Reels;
        forcedStops: Record<string, number>;
        randomOffset?: boolean;
    }): void;
    /**
     * Draws a board using random reel stops.
     */
    drawBoardWithRandomStops(reels: Reels): void;
    private drawBoardMixed;
    /**
     * Tumbles the board. All given symbols will be deleted and new symbols will fall from the top.
     */
    tumbleBoard(symbolsToDelete: Array<{
        reelIdx: number;
        rowIdx: number;
    }>): {
        newBoardSymbols: Record<string, GameSymbol[]>;
        newPaddingTopSymbols: Record<string, GameSymbol[]>;
    };
}

declare class Recorder {
    records: RecordItem[];
    pendingRecords: PendingRecord[];
    constructor();
}
interface PendingRecord {
    bookId: number;
    properties: Record<string, string>;
}
interface RecordItem {
    search: Array<{
        name: string;
        value: string;
    }>;
    timesTriggered: number;
    bookIds: number[];
}

declare class Book {
    readonly id: number;
    criteria: string;
    events: BookEvent[];
    payout: number;
    basegameWins: number;
    freespinsWins: number;
    constructor(opts: BookOpts);
    /**
     * Intended for internal use only.
     */
    setCriteria(criteria: string): void;
    /**
     * Adds an event to the book.
     */
    addEvent(event: Omit<BookEvent, "index">): void;
    /**
     * Intended for internal use only.
     */
    serialize(): {
        id: number;
        criteria: string;
        events: BookEvent[];
        payout: number;
        basegameWins: number;
        freespinsWins: number;
    };
    /**
     * Intended for internal use only.
     */
    static fromSerialized(data: ReturnType<Book["serialize"]>): Book;
}
interface BookEvent {
    index: number;
    type: string;
    data: Record<string, any>;
}
interface BookOpts {
    id: number;
    criteria: string;
}

declare class DataService<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> extends AbstractService {
    private recorder;
    private book;
    constructor(ctx: () => GameContext<TGameModes, TSymbols, TUserState>);
    private ensureRecorder;
    private ensureBook;
    /**
     * Intended for internal use only.
     */
    _setRecorder(recorder: Recorder): void;
    /**
     * Intended for internal use only.
     */
    _getBook(): Book;
    /**
     * Intended for internal use only.
     */
    _setBook(book: Book): void;
    /**
     * Intended for internal use only.
     */
    _getRecorder(): Recorder;
    /**
     * Intended for internal use only.
     */
    _getRecords(): RecordItem[];
    /**
     * Record data for statistical analysis.
     */
    record(data: Record<string, string | number | boolean>): void;
    /**
     * Records a symbol occurrence for statistical analysis.
     *
     * Calls `ctx.services.data.record()` with the provided data.
     */
    recordSymbolOccurrence(data: {
        kind: number;
        symbolId: string;
        spinType: SpinType;
        [key: string]: any;
    }): void;
    /**
     * Adds an event to the book.
     */
    addBookEvent(event: Omit<BookEvent, "index">): void;
    /**
     * Intended for internal use only.
     */
    _clearPendingRecords(): void;
}

declare class RngService<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> extends AbstractService {
    protected rng: RandomNumberGenerator;
    constructor(ctx: () => GameContext<TGameModes, TSymbols, TUserState>);
    /**
     * Random weighted selection from a set of items.
     */
    weightedRandom: <T extends Record<string, number>>(weights: T) => string;
    /**
     * Selects a random item from an array.
     */
    randomItem: <T>(array: T[]) => NonNullable<T>;
    /**
     * Shuffles an array.
     */
    shuffle: <T>(array: T[]) => T[];
    /**
     * Generates a random float between two values.
     */
    randomFloat: (low: number, high: number) => number;
    /**
     * Sets the seed for the RNG.
     */
    setSeedIfDifferent: (seed: number) => void;
}
declare class RandomNumberGenerator {
    mIdum: number;
    mIy: number;
    mIv: Array<number>;
    NTAB: number;
    IA: number;
    IM: number;
    IQ: number;
    IR: number;
    NDIV: number;
    AM: number;
    RNMX: number;
    protected _currentSeed: number;
    constructor();
    getCurrentSeed(): number;
    protected setCurrentSeed(seed: number): void;
    setSeed(seed: number): void;
    setSeedIfDifferent(seed: number): void;
    generateRandomNumber(): number;
    randomFloat(low: number, high: number): number;
    weightedRandom<T extends Record<string, number>>(weights: T): string;
    randomItem<T>(array: T[]): NonNullable<T>;
    shuffle<T>(array: T[]): T[];
}

declare class ReelSet {
    id: string;
    associatedGameModeName: string;
    reels: Reels;
    protected rng: RandomNumberGenerator;
    constructor(opts: ReelSetOptions);
    generateReels(config: GameConfig): ReelSet;
    /**
     * Reads a reelset CSV file and returns the reels as arrays of GameSymbols.
     */
    parseReelsetCSV(reelSetPath: string, config: GameConfig): Reels;
}
interface ReelSetOptions {
    /**
     * The unique identifier of the reel generator.\
     * Must be unique per game mode.
     */
    id: string;
    /**
     * Optional seed for the RNG to ensure reproducible results.
     *
     * Default seed is `0`.
     *
     * Note: Seeds 0 and 1 produce the same results.
     */
    seed?: number;
}

declare class GameMode {
    readonly name: string;
    readonly reelsAmount: number;
    readonly symbolsPerReel: number[];
    readonly cost: number;
    readonly rtp: number;
    readonly reelSets: ReelSet[];
    readonly resultSets: ResultSet<any>[];
    readonly isBonusBuy: boolean;
    constructor(opts: GameModeOpts);
}
interface GameModeOpts {
    /**
     * Name of the game mode.
     */
    name: string;
    /**
     * Number of reels the board has.
     */
    reelsAmount: number;
    /**
     * How many symbols each reel has. Array length must match `reelsAmount`.\
     * The number at an array index represents the number of symbols on that reel.
     */
    symbolsPerReel: number[];
    /**
     * Cost of the game mode, multiplied by the base bet.
     */
    cost: number;
    /**
     * The target RTP of the game.
     */
    rtp: number;
    /**
     * Defines (and generates) all reels for the game.\
     * Which reels are used in a spin is determined by the ResultSet of the current game mode.
     *
     * It is common to have one reel set for the base game and another for free spins.\
     * Each `ResultSet` can then set the weights of these reel sets to control which\
     * reel set is used for a specific criteria.
     */
    reelSets: ReelSet[];
    /**
     * A ResultSet defines how often a specific outcome should be generated.\
     * For example, a ResultSet can be used to force a specific ratio of max wins\
     * in the simulations to ensure there are different frontend representations.
     */
    resultSets: ResultSet<any>[];
    /**
     * Whether this game mode is a bonus buy.
     */
    isBonusBuy: boolean;
}

declare class GameService<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> extends AbstractService {
    constructor(ctx: () => GameContext<TGameModes, TSymbols, TUserState>);
    /**
     * Intended for internal use only.\
     * Generates reels for all reel sets in the game configuration.
     */
    _generateReels(): void;
    /**
     * Retrieves a reel set by its ID within a specific game mode.
     */
    getReelsetById(gameMode: string, id: string): Reels;
    /**
     * Retrieves the number of free spins awarded for a given spin type and scatter count.
     */
    getFreeSpinsForScatters(spinType: SpinType, scatterCount: number): number;
    /**
     * Retrieves a result set by its criteria within a specific game mode.
     */
    getResultSetByCriteria(mode: string, criteria: string): ResultSet<any>;
    /**
     * Returns all configured symbols as an array.
     */
    getSymbolArray(): GameSymbol[];
    /**
     * Gets the configuration for the current game mode.
     */
    getCurrentGameMode(): GameMode;
    /**
     * Ensures the requested number of scatters is valid based on the game configuration.\
     * Returns a valid number of scatters.
     */
    verifyScatterCount(numScatters: number): number;
    /**
     * Increases the freespin count by the specified amount.
     *
     * Also sets `state.triggeredFreespins` to true.
     */
    awardFreespins(amount: number): void;
}

declare class Wallet {
    /**
     * Total win amount (as the bet multiplier) from all simulations.
     */
    protected cumulativeWins: number;
    /**
     * Total win amount (as the bet multiplier) per spin type.
     *
     * @example
     * ```ts
     * {
     *   basegame: 50,
     *   freespins: 100,
     *   superfreespins: 200,
     * }
     * ```
     */
    protected cumulativeWinsPerSpinType: {
        basegame: number;
        freespins: number;
    };
    /**
     * Current win amount (as the bet multiplier) for the ongoing simulation.
     */
    protected currentWin: number;
    /**
     * Current win amount (as the bet multiplier) for the ongoing simulation per spin type.
     *
     * @example
     * ```ts
     * {
     *   basegame: 50,
     *   freespins: 100,
     *   superfreespins: 200,
     * }
     * ```
     */
    protected currentWinPerSpinType: {
        basegame: number;
        freespins: number;
    };
    /**
     * Holds the current win amount for a single (free) spin.\
     * After each spin, this amount is added to `currentWinPerSpinType` and then reset to zero.
     */
    protected currentSpinWin: number;
    /**
     * Current win amount (as the bet multiplier) for the ongoing tumble sequence.
     */
    protected currentTumbleWin: number;
    constructor();
    /**
     * Updates the win for the current spin.
     *
     * Should be called after each tumble event, if applicable.\
     * Or generally call this to add wins during a spin.
     *
     * After each (free) spin, this amount should be added to `currentWinPerSpinType` via `confirmSpinWin()`
     */
    addSpinWin(amount: number): void;
    /**
     * Confirms the wins of the current spin.
     *
     * Should be called after `addSpinWin()`, and after your tumble events are played out,\
     * and after a (free) spin is played out to finalize the win.
     */
    confirmSpinWin(spinType: SpinType): void;
    /**
     * Returns the accumulated win amount (as the bet multiplier) from all simulations.
     */
    getCumulativeWins(): number;
    /**
     * Returns the accumulated win amount (as the bet multiplier) per spin type from all simulations.
     */
    getCumulativeWinsPerSpinType(): {
        basegame: number;
        freespins: number;
    };
    /**
     * Returns the current win amount (as the bet multiplier) for the ongoing simulation.
     */
    getCurrentWin(): number;
    /**
     * Returns the current spin win amount (as the bet multiplier) for the ongoing simulation.
     */
    getCurrentSpinWin(): number;
    /**
     * Returns the current tumble win amount (as the bet multiplier) for the ongoing simulation.
     */
    getCurrentTumbleWin(): number;
    /**
     * Returns the current win amount (as the bet multiplier) per spin type for the ongoing simulation.
     */
    getCurrentWinPerSpinType(): {
        basegame: number;
        freespins: number;
    };
    /**
     * Adds a win to `currentSpinWin` and `currentTumbleWin`.
     *
     * After each (free) spin, this amount should be added to `currentWinPerSpinType` via `confirmSpinWin()`
     */
    addTumbleWin(amount: number): void;
    /**
     * Intended for internal use only.
     *
     * Resets the current win amounts to zero.
     */
    resetCurrentWin(): void;
    /**
     * Intended for internal use only.
     *
     * Adds current wins to cumulative wins and resets current wins to zero.
     */
    confirmWins(ctx: GameContext): void;
    /**
     * Intended for internal use only.
     *
     * Transfers the win data from the given wallet to the calling book.
     */
    writePayoutToBook(ctx: GameContext): void;
    /**
     * Intended for internal use only.
     */
    serialize(): {
        cumulativeWins: number;
        cumulativeWinsPerSpinType: {
            basegame: number;
            freespins: number;
        };
        currentWin: number;
        currentWinPerSpinType: {
            basegame: number;
            freespins: number;
        };
        currentSpinWin: number;
        currentTumbleWin: number;
    };
    /**
     * Intended for internal use only.
     */
    merge(wallet: Wallet): void;
    /**
     * Intended for internal use only.
     */
    mergeSerialized(data: ReturnType<Wallet["serialize"]>): void;
}

declare class WalletService<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> extends AbstractService {
    private wallet;
    constructor(ctx: () => GameContext<TGameModes, TSymbols, TUserState>);
    private ensureWallet;
    /**
     * Intended for internal use only.
     */
    _getWallet(): Wallet;
    /**
     * Intended for internal use only.
     */
    _setWallet(wallet: Wallet): void;
    /**
     * Adds the given amount to the wallet state.
     *
     * After calculating the win for a board, call this method to update the wallet state.\
     * If your game has tumbling mechanics, you should call this method again after every new tumble and win calculation.
     */
    addSpinWin(amount: number): void;
    /**
     * Helps to add tumble wins to the wallet state.
     *
     * This also calls `addSpinWin()` internally, to add the tumble win to the overall spin win.
     */
    addTumbleWin(amount: number): void;
    /**
     * Confirms the wins of the current spin.
     *
     * Should be called after `addSpinWin()`, and after your tumble events are played out,\
     * and after a (free) spin is played out to finalize the win.
     */
    confirmSpinWin(): void;
    /**
     * Gets the total win amount of the current simulation.
     */
    getCurrentWin(): number;
    /**
     * Gets the current spin win amount of the ongoing spin.
     */
    getCurrentSpinWin(): number;
    /**
     * Gets the current tumble win amount of the ongoing spin.
     */
    getCurrentTumbleWin(): number;
}

type GameContext<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> = {
    /**
     * The static configuration of the game.
     */
    config: GameConfig<TGameModes, TSymbols, TUserState>;
    /**
     * Game state holding information about the current simulation.
     */
    state: GameState<TUserState>;
    /**
     * Services providing game functionality.
     */
    services: GameContextServices;
};
interface GameContextServices {
    /**
     * Service providing common utility functions.
     */
    game: GameService;
    /**
     * Service for interacting with the book data or recorder.
     */
    data: DataService;
    /**
     * Service managing the game board and reels.
     */
    board: BoardService;
    /**
     * Service providing win related functionality.
     */
    wallet: WalletService;
    /**
     * Service for seeded random number generation.
     */
    rng: RngService;
}

declare class OptimizationParameters {
    protected parameters: OptimizationParametersOpts;
    constructor(opts?: Partial<OptimizationParametersOpts>);
    static DEFAULT_PARAMETERS: OptimizationParametersOpts;
    getParameters(): OptimizationParametersOpts;
}
interface OptimizationParametersOpts {
    readonly numShowPigs: number;
    readonly numPigsPerFence: number;
    readonly threadsFenceConstruction: number;
    readonly threadsShowConstruction: number;
    readonly testSpins: number[];
    readonly testSpinsWeights: number[];
    readonly simulationTrials: number;
    readonly graphIndexes: number[];
    readonly run1000Batch: false;
    readonly minMeanToMedian: number;
    readonly maxMeanToMedian: number;
    readonly pmbRtp: number;
    readonly scoreType: "rtp";
}

declare class OptimizationConditions {
    protected rtp?: number | "x";
    protected avgWin?: number;
    protected hitRate?: number | "x";
    protected searchRange: number[];
    protected forceSearch: Record<string, string>;
    priority: number;
    constructor(opts: OptimizationConditionsOpts);
    getRtp(): number | "x" | undefined;
    getAvgWin(): number | undefined;
    getHitRate(): number | "x" | undefined;
    getSearchRange(): number[];
    getForceSearch(): Record<string, string>;
}
interface OptimizationConditionsOpts {
    /**
     * The desired RTP (0-1)
     */
    rtp?: number | "x";
    /**
     * The desired average win (per spin).
     */
    avgWin?: number;
    /**
     * The desired hit rate (e.g. `200` to hit 1 in 200 spins).
     */
    hitRate?: number | "x";
    /**
     * A way of filtering results by
     *
     * - A number (payout multiplier), e.g. `5000`
     * - Force record value, e.g. `{ "symbolId": "scatter" }`
     * - A range of numbers, e.g. `[0, 100]` (payout multiplier range)
     */
    searchConditions?: number | Record<string, string> | [number, number];
    /**
     * **Priority matters!**\
     * Higher priority conditions will be evaluated first.\
     * After a book matching this condition is found, the book will be removed from the pool\
     * and can't be used to satisfy other conditions with lower priority.
     *
     * TODO add better explanation
     */
    priority: number;
}

declare class OptimizationScaling {
    protected config: OptimizationScalingOpts;
    constructor(opts: OptimizationScalingOpts);
    getConfig(): OptimizationScalingOpts;
}
type OptimizationScalingOpts = Array<{
    criteria: string;
    scaleFactor: number;
    winRange: [number, number];
    probability: number;
}>;

interface OptimizationOpts {
    gameModes: string[];
}
interface OptimizerOpts {
    game: SlotGame<any, any, any>;
    gameModes: OptimzierGameModeConfig;
}
type OptimzierGameModeConfig = Record<string, {
    conditions: Record<string, OptimizationConditions>;
    scaling: OptimizationScaling;
    parameters: OptimizationParameters;
}>;

interface AnalysisOpts {
    gameModes: string[];
}

/**
 * SlotGame class that encapsulates the game configuration and state.\
 * Main entry point for the slot game.
 */
declare class SlotGame<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> {
    private readonly configOpts;
    private simulation?;
    private optimizer?;
    private analyzer?;
    constructor(config: GameConfigOptions<TGameModes, TSymbols, TUserState>);
    /**
     * Sets up the simulation configuration.\
     * Must be called before `runTasks()`.
     */
    configureSimulation(opts: SimulationOptions): void;
    /**
     * Sets up the optimization configuration.\
     * Must be called before `runTasks()`.
     */
    configureOptimization(opts: Pick<OptimizerOpts, "gameModes">): void;
    /**
     * Runs the simulation based on the configured settings.
     */
    private runSimulation;
    /**
     * Runs the optimization based on the configured settings.
     */
    private runOptimization;
    /**
     * Runs the analysis based on the configured settings.
     */
    private runAnalysis;
    /**
     * Runs the configured tasks: simulation, optimization, and/or analysis.
     */
    runTasks(opts?: {
        doSimulation?: boolean;
        doOptimization?: boolean;
        doAnalysis?: boolean;
        simulationOpts?: SimulationConfigOptions;
        optimizationOpts?: OptimizationOpts;
        analysisOpts?: AnalysisOpts;
    }): Promise<void>;
    /**
     * Gets the game configuration.
     */
    getConfig(): {
        symbols: Map<keyof TSymbols & string, TSymbols[keyof TSymbols]>;
        anticipationTriggers: {
            basegame: number;
            freespins: number;
        };
        outputDir: string;
        rootDir: string;
        id: string;
        name: string;
        gameModes: TGameModes;
        scatterToFreespins: Record<string, Record<number, number>>;
        padSymbols: number;
        maxWinX: number;
        userState: TUserState;
        hooks: GameHooks<TGameModes, TSymbols, TUserState>;
    };
}

type InferGameType<TGameModes extends AnyGameModes, TSymbols extends AnySymbols, TUserState extends AnyUserData> = SlotGame<TGameModes, TSymbols, TUserState>;
/**
 * @internal
 */
type AnyUserData = Record<string, any>;
/**
 * @internal
 */
type AnyGameModes = Record<string, GameMode>;
/**
 * @internal
 */
type AnySymbols = Record<string, GameSymbol>;
/**
 * @internal
 */
interface GameHooks<TGameModes extends AnyGameModes = AnyGameModes, TSymbols extends AnySymbols = AnySymbols, TUserState extends AnyUserData = AnyUserData> {
    /**
     * This hook is called after the simulation state is prepared for a spin,\
     * and the core is ready to handle the game flow.
     *
     * **The developer is responsible for implementing the entire game flow here, including:**
     * - Drawing the board
     * - Evaluating wins
     * - Tumbling mechanics
     * - Updating wallet
     * - Handling free spins
     * - Recording events
     * - ... and everything in between.
     *
     * You can access the config and state from the context.
     *
     * The game flow is not built into the core, because it can vary greatly between different games.\
     * This hook provides the flexibility to implement any game flow you need.
     */
    onHandleGameFlow: (ctx: GameContext<TGameModes, TSymbols, TUserState>) => void;
    /**
     * This hook is called whenever a simulation is accepted, i.e. when the criteria of the current ResultSet is met.
     */
    onSimulationAccepted?: (ctx: GameContext<TGameModes, TSymbols, TUserState>) => void;
}
type SpinType = (typeof SPIN_TYPE)[keyof typeof SPIN_TYPE];
type Reels = GameSymbol[][];

declare function createSlotGame<TGame>(opts: TGame extends InferGameType<infer G, infer S, infer U> ? GameConfigOptions<G, S, U> : never): TGame;
declare const defineUserState: <TUserState extends AnyUserData>(data: TUserState) => TUserState;
declare const defineSymbols: <TSymbols extends AnySymbols>(symbols: TSymbols) => TSymbols;
declare const defineGameModes: <TGameModes extends AnyGameModes>(gameModes: TGameModes) => TGameModes;

declare class WinType {
    protected payout: number;
    protected winCombinations: WinCombination[];
    protected ctx: GameContext;
    protected readonly wildSymbol?: WildSymbol;
    constructor(opts: WinTypeOpts);
    /**
     * Implementation of win evaluation logic. Sets `this.payout` and `this.winCombinations`.
     */
    evaluateWins(board: Reels): this;
    /**
     * Custom post-processing of wins, e.g. for handling multipliers.
     */
    postProcess(func: PostProcessFn<typeof this.winCombinations>): this;
    /**
     * Returns the total payout and detailed win combinations.
     */
    getWins(): {
        payout: number;
        winCombinations: WinCombination[];
    };
    protected isWild(symbol: GameSymbol): boolean;
    protected getSymbolPayout(symbol: GameSymbol, count: number): number;
}
interface WinTypeOpts {
    /**
     * A reference to the game context.
     */
    ctx: GameContext<any, any, any>;
    /**
     * Configuration used to identify wild symbols on the board.\
     * You can either provide a specific `GameSymbol` instance or a set of properties to match against symbols on the board.
     *
     * @example
     * If you have different wild symbols, each with a property `isWild: true`, you can define:
     * ```ts
     * wildSymbol: { isWild: true }
     * ```
     *
     * @example
     * If you have a single wild symbol instance, you can define:
     * ```ts
     * wildSymbol: myWildSymbol
     * ```
     */
    wildSymbol?: WildSymbol;
}
type WinCombination = {
    payout: number;
    kind: number;
    baseSymbol: GameSymbol;
    symbols: Array<{
        symbol: GameSymbol;
        isWild: boolean;
        substitutedFor?: GameSymbol;
        reelIndex: number;
        posIndex: number;
    }>;
};
type PostProcessFn<TWinCombs extends WinCombination[]> = (wins: TWinCombs, ctx: GameContext) => {
    winCombinations: TWinCombs;
};
type WildSymbol = GameSymbol | Record<string, any>;

declare class LinesWinType extends WinType {
    protected lines: Record<number, number[]>;
    protected winCombinations: LineWinCombination[];
    getWins: () => {
        payout: number;
        winCombinations: LineWinCombination[];
    };
    constructor(opts: LinesWinTypeOpts);
    private validateConfig;
    /**
     * Calculates wins based on the defined paylines and provided board state.\
     * Retrieve the results using `getWins()` after.
     */
    evaluateWins(board: Reels): this;
    private getLinePayout;
}
interface LinesWinTypeOpts extends WinTypeOpts {
    /**
     * Defines the paylines for the slot game.
     *
     * @example
     * ```ts
     * lines: {
     *   1: [0, 0, 0, 0, 0],
     *   2: [1, 1, 1, 1, 1],
     *   3: [2, 2, 2, 2, 2],
     * }
     * ```
     */
    lines: Record<number, number[]>;
}
interface LineWinCombination extends WinCombination {
    lineNumber: number;
}

declare class ClusterWinType extends WinType {
    protected winCombinations: ClusterWinCombination[];
    getWins: () => {
        payout: number;
        winCombinations: ClusterWinCombination[];
    };
    private _checked;
    private _checkedWilds;
    private _currentBoard;
    constructor(opts: ClusterWinTypeOpts);
    private validateConfig;
    /**
     * Calculates wins based on symbol cluster size and provided board state.\
     * Retrieve the results using `getWins()` after.
     */
    evaluateWins(board: Reels): this;
    private getNeighbors;
    private evaluateCluster;
    private isChecked;
    private isCheckedWild;
}
interface ClusterWinTypeOpts extends WinTypeOpts {
}
interface ClusterWinCombination extends WinCombination {
}

declare class ManywaysWinType extends WinType {
    protected winCombinations: ManywaysWinCombination[];
    getWins: () => {
        payout: number;
        winCombinations: ManywaysWinCombination[];
    };
    constructor(opts: ManywaysWinTypeOpts);
    private validateConfig;
    /**
     * Calculates wins based on the defined paylines and provided board state.\
     * Retrieve the results using `getWins()` after.
     */
    evaluateWins(board: Reels): this;
    private getWayLength;
}
interface ManywaysWinTypeOpts extends WinTypeOpts {
}
interface ManywaysWinCombination extends WinCombination {
    ways: number;
}

/**
 * This class is responsible for generating reel sets for slot games based on specified configurations.
 *
 * **While it offers a high degree of customization, some configurations may lead to unsolvable scenarios.**
 *
 * If the reel generator is unable to fulfill niche constraints,\
 * you might need to adjust your configuration, or edit the generated reels manually.\
 * Setting a different seed may also help.
 */
declare class GeneratedReelSet extends ReelSet {
    protected readonly symbolWeights: Map<string, number>;
    protected readonly rowsAmount: number;
    protected limitSymbolsToReels?: Record<string, number[]>;
    protected readonly spaceBetweenSameSymbols?: number | Record<string, number>;
    protected readonly spaceBetweenSymbols?: Record<string, Record<string, number>>;
    protected readonly preferStackedSymbols?: number;
    protected readonly symbolStacks?: Record<string, {
        chance: number | Record<string, number>;
        min?: number | Record<string, number>;
        max?: number | Record<string, number>;
    }>;
    protected readonly symbolQuotas?: Record<string, number | Record<string, number>>;
    private overrideExisting;
    constructor(opts: GeneratedReelSetOptions);
    private validateConfig;
    private isSymbolAllowedOnReel;
    private resolveStacking;
    private tryPlaceStack;
    /**
     * Checks if a symbol can be placed at the target index without violating spacing rules.
     */
    private violatesSpacing;
    generateReels(config: GameConfig): this;
}
interface GeneratedReelSetOptions extends ReelSetOptions {
    /**
     * The weights of the symbols in the reelset.\
     * This is a mapping of symbol IDs to their respective weights.
     */
    symbolWeights: Record<string, number>;
    /**
     * The number of rows in the reelset.\
     * Default is 250, but can be adjusted as needed.
     */
    rowsAmount?: number;
    /**
     * Prevent the same symbol from appearing directly above or below itself.\
     * This can be a single number for all symbols, or a mapping of symbol IDs to
     * their respective spacing values.
     *
     * Must be 1 or higher, if set.
     *
     * **This is overridden by `symbolStacks`**
     */
    spaceBetweenSameSymbols?: number | Record<string, number>;
    /**
     * Prevents specific symbols from appearing within a certain distance of each other.
     *
     * Useful for preventing scatter and super scatter symbols from appearing too close to each other.
     *
     * **This is overridden by `symbolStacks`**
     */
    spaceBetweenSymbols?: Record<string, Record<string, number>>;
    /**
     * A percentage value 0-100 that indicates the likelihood of a symbol being stacked.\
     * A value of 0 means no stacked symbols, while 100 means all symbols are stacked.
     *
     * This is only a preference. Symbols may still not be stacked if\
     * other restrictions (like `spaceBetweenSameSymbols`) prevent it.
     *
     * **This is overridden by `symbolStacks`**
     */
    preferStackedSymbols?: number;
    /**
     * A mapping of symbols to their respective advanced stacking configuration.
     *
     * @example
     * ```ts
     * symbolStacks: {
     *   "W": {
     *     chance: { "1": 20, "2": 20, "3": 20, "4": 20 }, // 20% chance to be stacked on reels 2-5
     *     min: 2, // At least 2 wilds in a stack
     *     max: 4, // At most 4 wilds in a stack
     *   }
     * }
     * ```
     */
    symbolStacks?: Record<string, {
        chance: number | Record<string, number>;
        min?: number | Record<string, number>;
        max?: number | Record<string, number>;
    }>;
    /**
     * Configures symbols to be limited to specific reels.\
     * For example, you could configure Scatters to appear only on reels 1, 3 and 5.
     *
     * @example
     * ```ts
     * limitSymbolsToReels: {
     *   "S": [0, 2, 4], // Remember that reels are 0-indexed.
     * }
     * ```
     */
    limitSymbolsToReels?: Record<string, number[]>;
    /**
     * Defines optional quotas for symbols on the reels.\
     * The quota (1-100%) defines how often a symbol should appear in the reelset, or in a specific reel.
     *
     * This is particularly useful for controlling the frequency of special symbols like scatters or wilds.
     *
     * Reels not provided for a symbol will use the weights from `symbolWeights`.
     *
     * _Any_ small quota will ensure that the symbol appears at least once on the reel.
     *
     * @example
     * ```ts
     * symbolQuotas: {
     *   "S": 3, // 3% of symbols on each reel will be scatters
     *   "W": { "1": 10, "2": 5, "3": 3, "4": 1 }, // Wilds will appear with different quotas on selected reels
     * }
     * ```
     */
    symbolQuotas?: Record<string, number | Record<string, number>>;
    /**
     * If true, existing reels CSV files will be overwritten.
     */
    overrideExisting?: boolean;
    /**
     * Optional seed for the RNG to ensure reproducible results.
     *
     * Default seed is `0`.
     *
     * Note: Seeds 0 and 1 produce the same results.
     */
    seed?: number;
}

/**
 * This class is responsible for providing reel sets for slot games based on a static configuration or file.
 */
declare class StaticReelSet extends ReelSet {
    reels: Reels;
    csvPath: string;
    private _strReels;
    constructor(opts: StaticReelSetOptions);
    private validateConfig;
    generateReels(config: GameConfig): this;
}
interface StaticReelSetOptions extends ReelSetOptions {
    reels?: string[][];
    csvPath?: string;
}

declare class StandaloneBoard {
    private board;
    private ctx;
    private reelsAmount;
    private symbolsPerReel;
    private padSymbols;
    constructor(opts: StandaloneBoardOptions);
    /**
     * Resets the board to an empty state.\
     * This is called before drawing a new board.
     */
    resetBoard(): void;
    /**
     * Gets the current reels and symbols on the board.
     */
    getBoardReels(): Reels;
    getPaddingTop(): Reels;
    getPaddingBottom(): Reels;
    /**
     * Gets the symbol at the specified reel and row index.
     */
    getSymbol(reelIndex: number, rowIndex: number): GameSymbol | undefined;
    /**
     * Sets the symbol at the specified reel and row index.
     */
    setSymbol(reelIndex: number, rowIndex: number, symbol: GameSymbol): void;
    private resetReels;
    /**
     * Sets the anticipation value for a specific reel.
     */
    setAnticipationForReel(reelIndex: number, value: boolean): void;
    /**
     * Counts how many symbols matching the criteria are on a specific reel.
     */
    countSymbolsOnReel(symbolOrProperties: GameSymbol | Record<string, any>, reelIndex: number): number;
    /**
     * Counts how many symbols matching the criteria are on the board.
     *
     * Passing a GameSymbol will compare by ID, passing a properties object will compare by properties.
     *
     * Returns a tuple where the first element is the total count, and the second element is a record of counts per reel index.
     */
    countSymbolsOnBoard(symbolOrProperties: GameSymbol | Record<string, any>): [number, Record<number, number>];
    /**
     * Checks if a symbol appears more than once on any reel in the current reel set.
     *
     * Useful to check for "forbidden" generations, e.g. 2 scatters on one reel.
     */
    isSymbolOnAnyReelMultipleTimes(symbol: GameSymbol): boolean;
    /**
     * Gets all reel stops (positions) where the specified symbol appears in the current reel set.\
     * Returns an array of arrays, where each inner array contains the positions for the corresponding reel.
     */
    getReelStopsForSymbol(reels: Reels, symbol: GameSymbol): number[][];
    /**
     * Combines multiple arrays of reel stops into a single array of reel stops.\
     */
    combineReelStops(...reelStops: number[][][]): number[][];
    /**
     * From a list of reel stops on reels, selects a random stop for a speficied number of random symbols.
     *
     * Mostly useful for placing scatter symbols on the board.
     */
    getRandomReelStops(reels: Reels, reelStops: number[][], amount: number): Record<number, number>;
    /**
     * Selects a random reel set based on the configured weights of the current result set.\
     * Returns the reels as arrays of GameSymbols.
     */
    getRandomReelset(): Reels;
    /**
     * Draws a board using specified reel stops.
     */
    drawBoardWithForcedStops(opts: {
        reels: Reels;
        forcedStops: Record<string, number>;
        randomOffset?: boolean;
    }): void;
    /**
     * Draws a board using random reel stops.
     */
    drawBoardWithRandomStops(reels: Reels): void;
    private drawBoardMixed;
    /**
     * Tumbles the board. All given symbols will be deleted and new symbols will fall from the top.
     */
    tumbleBoard(symbolsToDelete: Array<{
        reelIdx: number;
        rowIdx: number;
    }>): {
        newBoardSymbols: Record<string, GameSymbol[]>;
        newPaddingTopSymbols: Record<string, GameSymbol[]>;
    };
}
interface StandaloneBoardOptions {
    ctx: GameContext;
    reelsAmount: number;
    symbolsPerReel: number[];
    padSymbols: number;
}

export { type AnyGameModes, type AnySymbols, type AnyUserData, ClusterWinType, type GameContext, type GameHooks, GameMode, GameSymbol, GeneratedReelSet, type InferGameType, LinesWinType, ManywaysWinType, OptimizationConditions, OptimizationParameters, OptimizationScaling, type Reels, ResultSet, SPIN_TYPE, type SpinType, StandaloneBoard, StaticReelSet, createSlotGame, defineGameModes, defineSymbols, defineUserState };
